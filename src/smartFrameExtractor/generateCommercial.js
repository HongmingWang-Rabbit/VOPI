#!/usr/bin/env node

/**
 * generateCommercial.js - Standalone CLI for commercial image generation
 *
 * WHY this exists:
 * - Allows testing image generation without re-running full pipeline
 * - Can be used on already-extracted frames
 * - Faster iteration when tuning prompts/settings
 *
 * Uses Photoroom API for:
 * - Background removal (preserves product exactly, including all text)
 * - Outputs transparent PNG ready for any background
 *
 * Usage:
 *   node src/smartFrameExtractor/generateCommercial.js <output_folder> [options]
 *
 * Example:
 *   node src/smartFrameExtractor/generateCommercial.js ./output/IMG_9876
 */

import dotenv from 'dotenv';
dotenv.config();

import { parseArgs } from 'node:util';
import { readdir, mkdir, readFile } from 'fs/promises';
import { existsSync } from 'fs';
import path from 'path';

import { removeBackground, editImageWithAI, processFrames, generateAllVersions } from './photoroom.js';

/**
 * CLI argument definitions
 */
const CLI_OPTIONS = {
  'single': {
    type: 'string',
    short: 's',
    description: 'Process a single frame file (filename in final_frames)'
  },
  'ai-cleanup': {
    type: 'boolean',
    short: 'a',
    default: false,
    description: 'Force AI cleanup even without obstructions (requires Plus plan)'
  },
  'no-ai-cleanup': {
    type: 'boolean',
    default: false,
    description: 'Disable AI cleanup even if obstructions detected'
  },
  'versions': {
    type: 'string',
    short: 'v',
    default: 'all',
    description: 'Versions to generate: all, transparent, solid, real, creative (comma-separated)'
  },
  'transparent-only': {
    type: 'boolean',
    short: 't',
    default: false,
    description: 'Only generate transparent PNG (legacy mode)'
  },
  'dry-run': {
    type: 'boolean',
    default: false,
    description: 'Show what would be processed without calling API'
  },
  'help': {
    type: 'boolean',
    short: 'h',
    default: false,
    description: 'Show this help message'
  }
};

/**
 * Print usage information
 */
function printHelp() {
  console.log(`
Commercial Image Generation (Photoroom API)

Removes backgrounds from product frames, outputting transparent PNGs.
Uses Photoroom API - preserves product exactly including all text/labels.

Usage:
  node src/smartFrameExtractor/generateCommercial.js <output_folder> [options]

Arguments:
  output_folder    Path to pipeline output folder (e.g., ./output/IMG_9876)

Environment:
  PHOTOROOM_API_KEY    Required. Get from https://www.photoroom.com/api

Options:`);

  for (const [name, opt] of Object.entries(CLI_OPTIONS)) {
    const short = opt.short ? `-${opt.short}, ` : '    ';
    const defaultVal = opt.default !== undefined ? ` (default: ${opt.default})` : '';
    console.log(`  ${short}--${name.padEnd(18)} ${opt.description}${defaultVal}`);
  }

  console.log(`
Output:
  Multiple image versions in commercial_images/ folder:
  - *_transparent.png  - Transparent background (for custom compositing)
  - *_solid.png        - Solid color background (Gemini-recommended)
  - *_real.png         - Real-life setting (e.g., on marble table)
  - *_creative.png     - Creative/artistic shot

Examples:
  # Generate all versions (default)
  node src/smartFrameExtractor/generateCommercial.js ./output/IMG_9876

  # Only transparent PNGs (legacy mode, faster)
  node src/smartFrameExtractor/generateCommercial.js ./output/IMG_9876 --transparent-only

  # Specific versions only
  node src/smartFrameExtractor/generateCommercial.js ./output/IMG_9876 --versions transparent,solid

  # Process a single frame only (for testing)
  node src/smartFrameExtractor/generateCommercial.js ./output/IMG_9876 --single product_1_variant_1_frame_00008_t0.70.png

  # Dry run to see what would be processed
  node src/smartFrameExtractor/generateCommercial.js ./output/IMG_9876 --dry-run

Note:
  AI cleanup is auto-enabled for frames with obstructions (hands, etc.).
  Background recommendations are generated by Gemini during frame analysis.
  Re-run the main pipeline to get updated background recommendations.
`);
}

/**
 * Parse frame metadata from filename
 * Format: {product}_{variant}_{frameId}_t{timestamp}.png
 * Example: product_1_variant_1_frame_00001_t0.00.png
 */
function parseFrameFilename(filename) {
  // Match new variant pattern: product_1_variant_1_frame_00001_t0.00.png
  const variantMatch = filename.match(/^(.+?)_(variant_\d+)_(frame_\d+)_t([\d.]+)\.png$/);

  if (variantMatch) {
    const [, productId, variantId, frameId, timestamp] = variantMatch;
    return {
      filename,
      productId,
      variantId,
      frameId,
      timestamp: parseFloat(timestamp),
      recommendedType: `${productId}_${variantId}`
    };
  }

  // Fallback: old angle-based pattern (product_1_hero_frame_00001_t0.00.png)
  const angleMatch = filename.match(/^(.+?)_([a-z_]+)_(frame_\d+)_t([\d.]+)\.png$/);

  if (angleMatch) {
    const [, productId, angle, frameId, timestamp] = angleMatch;
    return {
      filename,
      productId,
      variantId: angle, // Treat angle as variant for backwards compatibility
      frameId,
      timestamp: parseFloat(timestamp),
      recommendedType: `${productId}_${angle}`
    };
  }

  return null;
}

/**
 * Load frames metadata from JSON file (includes obstruction info)
 */
async function loadFramesMetadata(outputFolder) {
  const metadataPath = path.join(outputFolder, 'frames_metadata.json');

  if (!existsSync(metadataPath)) {
    return null; // No metadata file
  }

  try {
    const data = await readFile(metadataPath, 'utf-8');
    return JSON.parse(data);
  } catch (e) {
    console.warn(`[warn] Could not load frames_metadata.json: ${e.message}`);
    return null;
  }
}

/**
 * Load frames from final_frames directory
 */
async function loadFinalFrames(outputFolder) {
  const finalDir = path.join(outputFolder, 'final_frames');

  if (!existsSync(finalDir)) {
    throw new Error(`final_frames directory not found: ${finalDir}`);
  }

  // Try to load metadata with obstruction info
  const metadata = await loadFramesMetadata(outputFolder);
  const metadataMap = new Map();
  if (metadata) {
    for (const m of metadata) {
      metadataMap.set(m.filename, m);
    }
    console.log(`[info] Loaded obstruction metadata for ${metadata.length} frames`);
  }

  const files = await readdir(finalDir);
  const frames = [];

  for (const file of files) {
    if (!file.endsWith('.png')) continue;

    const parsed = parseFrameFilename(file);
    if (parsed) {
      // Merge with metadata if available
      const meta = metadataMap.get(file);
      frames.push({
        ...parsed,
        path: path.join(finalDir, file),
        obstructions: meta?.obstructions || null,
        backgroundRecommendations: meta?.backgroundRecommendations || {
          solid_color: '#FFFFFF',
          solid_color_name: 'white',
          real_life_setting: 'on a clean white surface with soft natural lighting',
          creative_shot: 'floating with soft shadow on a light gradient background'
        }
      });
    } else {
      console.warn(`[warn] Could not parse filename: ${file}`);
    }
  }

  return frames;
}

/**
 * Main function
 */
async function main() {
  const { values: args, positionals } = parseArgs({
    options: CLI_OPTIONS,
    allowPositionals: true
  });

  if (args.help) {
    printHelp();
    process.exit(0);
  }

  // Check API key first
  const apiKey = process.env.PHOTOROOM_API_KEY;
  if (!apiKey && !args['dry-run']) {
    console.error('Error: PHOTOROOM_API_KEY environment variable not set.');
    console.error('Get your API key from: https://www.photoroom.com/api');
    console.error('Add it to your .env file: PHOTOROOM_API_KEY=your_key_here');
    process.exit(1);
  }

  // Check for output folder argument
  if (positionals.length === 0) {
    console.error('Error: Please provide the output folder path');
    console.error('Usage: node generateCommercial.js <output_folder> [options]');
    console.error('Run with --help for more information');
    process.exit(1);
  }

  const outputFolder = positionals[0];

  // Validate folder exists
  if (!existsSync(outputFolder)) {
    console.error(`Error: Output folder not found: ${outputFolder}`);
    process.exit(1);
  }

  // Load frames
  console.log(`Loading frames from: ${outputFolder}`);
  let frames = await loadFinalFrames(outputFolder);

  if (frames.length === 0) {
    console.error('Error: No frames found in final_frames directory');
    process.exit(1);
  }

  console.log(`Found ${frames.length} frames`);

  // Filter to single frame if specified
  if (args.single) {
    frames = frames.filter(f => f.filename === args.single);
    if (frames.length === 0) {
      console.error(`Error: Frame not found: ${args.single}`);
      process.exit(1);
    }
  }

  // Setup output directory
  const commercialDir = path.join(outputFolder, 'commercial_images');
  await mkdir(commercialDir, { recursive: true });

  // Count frames with obstructions
  const framesWithObstructions = frames.filter(f => f.obstructions?.has_obstruction);

  // Auto-enable AI cleanup if obstructions detected, unless explicitly disabled
  let useAIEdit = false;
  if (args['no-ai-cleanup']) {
    useAIEdit = false;
    if (framesWithObstructions.length > 0) {
      console.log(`[warn] AI cleanup disabled - ${framesWithObstructions.length} frames have obstructions that won't be removed`);
    }
  } else if (args['ai-cleanup']) {
    useAIEdit = true;
  } else if (framesWithObstructions.length > 0) {
    useAIEdit = true;
    console.log(`[auto] Detected ${framesWithObstructions.length} frames with obstructions - enabling AI cleanup`);
  }

  // Determine which versions to generate
  let versions = ['transparent', 'solid', 'real', 'creative'];
  if (args['transparent-only']) {
    versions = ['transparent'];
  } else if (args.versions && args.versions !== 'all') {
    versions = args.versions.split(',').map(v => v.trim());
  }

  console.log('='.repeat(50));
  console.log('Commercial Image Generation (Photoroom API)');
  console.log('='.repeat(50));
  console.log(`Output folder: ${outputFolder}`);
  console.log(`Frames to process: ${frames.length}`);
  console.log(`Versions to generate: ${versions.join(', ')}`);
  if (framesWithObstructions.length > 0) {
    console.log(`Frames with obstructions: ${framesWithObstructions.length}`);
    for (const f of framesWithObstructions) {
      console.log(`  - ${f.recommendedType}: ${f.obstructions.obstruction_types.join(', ')}`);
    }
  }
  console.log(`AI cleanup: ${useAIEdit ? 'Enabled (for obstructed frames)' : 'Disabled'}`);
  console.log('='.repeat(50));

  // Dry run - just show what would be done
  if (args['dry-run']) {
    console.log('\n[DRY RUN] Would generate:');
    for (const frame of frames) {
      const baseName = `${frame.recommendedType}_${frame.frameId}`;
      const obs = frame.obstructions?.has_obstruction
        ? ` [will remove: ${frame.obstructions.obstruction_types.join(', ')}]`
        : '';
      console.log(`\n  ${frame.filename}${obs}`);
      for (const v of versions) {
        const suffix = v === 'transparent' ? '_transparent.png' :
                       v === 'solid' ? `_solid.png (${frame.backgroundRecommendations?.solid_color || '#FFFFFF'})` :
                       v === 'real' ? '_real.png' : '_creative.png';
        console.log(`    -> ${baseName}${suffix}`);
      }
      if (frame.backgroundRecommendations) {
        const bg = frame.backgroundRecommendations;
        if (versions.includes('real')) {
          console.log(`       Real: "${bg.real_life_setting?.slice(0, 50)}..."`);
        }
        if (versions.includes('creative')) {
          console.log(`       Creative: "${bg.creative_shot?.slice(0, 50)}..."`);
        }
      }
    }
    console.log(`\nTotal images: ${frames.length * versions.length}`);
    console.log('\nRun without --dry-run to actually process images.');
    process.exit(0);
  }

  console.log(`\nGenerating ${versions.length} version(s) per frame...\n`);

  // Process all frames with all versions
  const allResults = {
    successful: 0,
    failed: 0,
    details: []
  };

  for (let i = 0; i < frames.length; i++) {
    const frame = frames[i];
    const obsInfo = frame.obstructions?.has_obstruction
      ? ` [obstructions: ${frame.obstructions.obstruction_types.join(', ')}]`
      : '';
    console.log(`\n[${i + 1}/${frames.length}] ${frame.recommendedType}${obsInfo}`);

    const result = await generateAllVersions(frame, commercialDir, apiKey, {
      useAIEdit,
      versions
    });

    allResults.details.push(result);
    for (const [version, vResult] of Object.entries(result.versions)) {
      if (vResult.success) {
        allResults.successful++;
      } else {
        allResults.failed++;
        console.error(`  [${version}] Failed: ${vResult.error}`);
      }
    }

    // Delay between frames
    if (i < frames.length - 1) {
      await new Promise(r => setTimeout(r, 500));
    }
  }

  // Summary
  console.log('\n' + '='.repeat(50));
  console.log('PROCESSING COMPLETE');
  console.log('='.repeat(50));
  console.log(`Total images generated: ${allResults.successful}`);
  console.log(`Failed: ${allResults.failed}`);
  console.log(`Output: ${commercialDir}`);

  if (allResults.failed > 0) {
    console.log('\nFailed versions:');
    for (const detail of allResults.details) {
      for (const [version, vResult] of Object.entries(detail.versions)) {
        if (!vResult.success) {
          console.log(`  - ${detail.recommendedType} [${version}]: ${vResult.error}`);
        }
      }
    }
  }

  console.log('='.repeat(50));
}

main().catch(err => {
  console.error('Error:', err.message);
  process.exit(1);
});
